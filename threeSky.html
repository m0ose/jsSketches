<html>
    <script src="https://cdn.jsdelivr.net/gh/lizard-isana/orb.js@2.3/build/orb.v2.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
<body>
<script type=module>
    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r99/three.module.js'
    window.THREE = THREE
    window.module ={}
    console.log(THREE)

    setTimeout(main, 1);
    async function main(){
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 95, window.innerWidth / window.innerHeight, 0.1, 300000 );
        window.camera = camera
        var renderer = new THREE.WebGLRenderer();
        window.renderer=renderer
        window.scene = scene
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        const stars = await loadStars()
        console.log('stars', stars)
        // 36.25981 102.57058
        const LON = 102.57058
        const LAT = 35.25981
        const DATE = new Date("2020-6-21 00:53")
        await addStars(scene, stars, LON, LAT, DATE)
        await addPlanets(scene, LON, LAT, DATE)
        makeRings(scene)
        console.log('Done adding stars and planets')
        renderer.render( scene, camera );
        //
        let [x,y,z] = raDec2XYZ(431, 23)
        // let [x,y,z] = raDec2XYZ(0, 89) // polaris
        let vector = new THREE.Vector3( x,y,z)
        camera.lookAt(vector)
        renderer.render( scene, camera );


    }

    /**
     * Place planets on celestial sphere.
     *   Just to confuse things a bit more this takes ra in degrees
     * 
     * @param {degrees} ra
     * @param {degrees} dec
     * @param {degrees} lon
     * @param {degrees} lat
     * @param {Date} date
     * @param {Number} distanceto place celestial sphere
     * */
    function raDec2XYZ(ra,dec, lon=-106, lat=35,date=new Date(), distance=110000, offsetAlt=0, offsetAz=0){
        var your_location = {
            "latitude":lat,
            "longitude":lon,
            "altitude":0
        }

        const star = {
            "ra":24*ra/360,
            "dec":dec,
            "distance":distance
        }
        const observe_star = new Orb.Observation({
            "observer":your_location ,
            "target":star
        });
        const horizontal = observe_star.azel(date); 
        // console.log(horizontal)
        const azimuth = (horizontal.azimuth + offsetAz) * (Math.PI/180)
        const elev = (horizontal.elevation + offsetAlt) * (Math.PI/180)
        const celR = horizontal.distance
        const y = Math.sin(elev) * celR 
        const x = Math.sin(azimuth) * Math.cos(elev) * celR 
        const z = -Math.cos(azimuth) * Math.cos(elev) *  celR

        return [x,y,z]
    }

    window.raDec2XYZ = raDec2XYZ

    async function addStars( scene, stars, lon=-106, lat=35, date=new Date(), offsetAlt=0, offsetAz=0){
        var your_location = {
            "latitude":lat,
            "longitude":lon,
            "altitude":0
        }

        for(let i=0; i<stars.declination.length; i++){
            const ra = stars.rightAscension[i] * (180/Math.PI)
            const dec = stars.declination[i] * (180/Math.PI)
            const mag = ((8-stars.apparentMagnitude[i])**2)*40

            let [x,y,z] = raDec2XYZ(ra, dec, lon, lat, date, offsetAlt, offsetAz)
            let colorIndex = Math.floor(((stars.colorIndexBV[i] + 0.27)/3.9)*stars.color.length)
            colorIndex = Math.min(stars.color.length-1, colorIndex)
            const colour = stars.color[colorIndex]
           
            const geometry = new THREE.BoxGeometry(mag,mag,mag);
            const color = `rgb(${Math.floor(255*colour[0])},${Math.floor(255*colour[1])},${Math.floor(255*colour[2])})`
            const material = new THREE.MeshBasicMaterial( { color:color} );
            const cube = new THREE.Mesh( geometry, material );
            scene.add( cube );
            cube.position.x = x
            cube.position.y = y
            cube.position.z = z
    
        }
    }

    async function addPlanets(scene, lon=-106, lat=35, date=new Date()){
        console.log('planets',date)
        const planets = [
        {name:"Sun", color:0xffff44}
        ,{name:"Mercury", color:0xffff00}
        ,{name:"Venus", color:0x00ff55}
        // ,{name:"Earth", color:0xff0000}
        ,{name:"Moon", color:0x999999}
        ,{name:"Mars", color:0xff0000}
        ,{name:"Jupiter", color:0xff00ff}
        ,{name:"Saturn", color:0x0044aa}
        ,{name:"Uranus", color:0x5500ff}
        ,{name:"Neptune", color:0x00ffff}
        ]
        // const planets = ["Sun", "Moon","Mercury","Venus","Earth"]
        for (let planZ of planets){
            let celestialSphereRadius = 100000
            let dist = undefined
            let color =  planZ.color
            let name = planZ.name
            let planetRadius = 500
            try{
                let planet = new Orb.VSOP(name);
                if (name == 'Sun') {
                    planet = new Orb.Sun()
                    dist = 1
                    planetRadius = 6000
                }
                if (name == 'Moon'){
                    planet = new Orb.Moon()
                    dist = 0.0002
                    planetRadius = 1
                }
                const radec = planet.radec(date); // ecliptic rectangular coordinates(x, y, z)
                const ra = radec.ra * 360/24
                const dec = radec.dec
                dist = dist || radec.distance
                let [x,y,z] = raDec2XYZ(ra, dec, lon, lat,date, dist)
                const geometry = new THREE.SphereGeometry( planetRadius, 32, 32 );
                const material = new THREE.MeshBasicMaterial( {color} );
                const sphere = new THREE.Mesh( geometry, material );
                sphere.position.x = x * celestialSphereRadius
                sphere.position.y = y * celestialSphereRadius
                sphere.position.z = z * celestialSphereRadius
                scene.add( sphere );
                console.log({planet,p:sphere.position, dist, ra, dec})
            } catch(err){
                console.error(planZ)
                console.error(err)
            }
        }
    }
    window.addPlanets = addPlanets

    async function loadStars() {
        const resp = await fetch('./starData.json')
        const json = await resp.json()
        //console.log(json)
        return json
    }

    function makeRings(scene) {
        var material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
        for (var dec=-90;dec<=85;dec += 15) {
            let points = []
            let [x1,y1,z1] = raDec2XYZ(0, dec)
            points.push(new THREE.Vector3( x1,y1,z1 ) )
            for (var ra = 1; ra<=360;ra += 1 ) {
                let [x2,y2,z2] = raDec2XYZ(ra, dec)
                points.push(new THREE.Vector3( x2,y2,z2 ) )
            }
            var geometry = new THREE.BufferGeometry().setFromPoints( points );
            var line = new THREE.Line( geometry, material );
            scene.add( line );
        }
        var material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
        for (var ra = 0; ra<360; ra += 15) {
            let points = []
            let [x1,y1,z1] = raDec2XYZ(ra, -75)
            points.push(new THREE.Vector3( x1,y1,z1 ) )
            for (var dec=-90;dec<=90;dec += 1 ) {
                if (ra%90 == 0 || Math.abs(dec)<=75){
                    let [x2,y2,z2] = raDec2XYZ(ra, dec)
                    points.push(new THREE.Vector3( x2,y2,z2 ) )
                }
            }
            var geometry = new THREE.BufferGeometry().setFromPoints( points );
            var line = new THREE.Line( geometry, material );
            scene.add( line );
        }
    }



</script>

</body>

</html>