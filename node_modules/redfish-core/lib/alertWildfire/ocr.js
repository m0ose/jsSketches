import {timezoneLookup} from '../utils/timezoneLookup.js'
import {DateTime} from '../../../../node_modules/luxon/src/luxon.js'
import {compareTwoStrings} from '../utils/string-similarity.js'
import {cameras as camJson} from './cameras.js'

export async function OCRAlertWildfireImage(img) {
    const result = {}
    // load camera jsons
    // let camJson = await loadCameraJson('./cameras.json')
    // start worker
    if(!tessWorker) {
        tessWorker = Tesseract.createWorker({IS_BROWSER:true,
            logger: function(m){console.info(m)}})
        await tessWorker.load()
        await tessWorker.loadLanguage('eng')
        await tessWorker.initialize('eng')
    }
    // recognise text
    const rectangle = { left: 0, top: img.height-36, width: img.width, height: 36 }
    const ocr = await tessWorker.recognize(img, { rectangle })
    result.text = ocr.data.text
    console.log('tesseract OCR:',ocr,ocr.data.text)
    // find geojson representing camera
    try{
        let closestFeature = getMostLikelyIDInJSON(camJson, ocr.data.text)
        console.log('closest feature', closestFeature)
        result.lat = parseFloat(closestFeature.geometry.coordinates[1])
        result.lon = parseFloat(closestFeature.geometry.coordinates[0])
    } catch(err) {
        console.warn('unable to get lat lon from ocr',err)
    }
    try {
        const photoDate = getDateFromOCR(ocr.data.text)
        // timezone 
        const timezoned = getTimezoneOffsetFromLatLon(result.lat, result.lon, photoDate.getTime())
        console.log({timezoned})
        const timezoneOffset = timezoned.offset
        const local = DateTime.fromMillis(photoDate.getTime())
        const creatorTzOffset = local.offset
        const tzDiff = (creatorTzOffset - timezoneOffset) 
        result.date = new Date(photoDate.getTime() + tzDiff*60*1000)
        result.timezoneOffsetM = tzDiff
        console.log('date', photoDate, timezoneOffset)
    } catch(err) {
        console.warn('unable to get date from ocr',err)
    }
    // find x y z rotations
    try{
        const xr = getNumericValFromOCR(ocr.data.text,'x:')
        const yr = getNumericValFromOCR(ocr.data.text,'y:')
        const zr = getNumericValFromOCR(ocr.data.text,'z:')
        result.x=xr
        result.y=yr
        result.z=zr
    } catch(err) {
        console.warn('unable to get rotations',err)
    }
    return result
}

function getTimezoneOffsetFromLatLon(lat, lon, startUTC){
    let tzone = timezoneLookup(lat,lon)
    let local = DateTime.fromMillis(startUTC)
    let rezoned = local.setZone(tzone);
    return rezoned
}

async function loadCameraJson(url='./cameras.json'){
    let response = await fetch(url)
    let data = await response.json()
    console.log('wf cams', data)
    return data
}

function getMostLikelyIDInJSON(geojson, OCRtext) {
    let sorted = geojson.features.sort((a,b)=>{
        let goal = OCRtext.split(' ')[0].toLowerCase()
        let sa = compareTwoStrings(goal,a.properties.id.toLowerCase())
        let sb = compareTwoStrings(goal,b.properties.id.toLowerCase())
        // console.log(a.properties.id, b.properties.id,sa,sb)
        return sb-sa  
    })
    return sorted[0]
}

function getDateFromOCR(ocrText) {
    const x = ocrText.split(' ')
    let i =0;
    for(i=0;i<x.length; i++) {
        if (!isNaN(new Date(x[i]))) {
            break;
        }
    }
    const ds = `${x[i]} ${x[i+1]}`
    const result = new Date(ds)
    return result
}

function getNumericValFromOCR(ocrText, delimiter='x:'){
    const x = ocrText.toLowerCase().split(' ')
    const x1 = x.filter((a)=>{
        return a.search(delimiter) >= 0
    })
    if(x1.length == 0) return 0
    const x2 = x1[0]
    const x3 = parseFloat(x2.slice(delimiter.length))
    return x3
}